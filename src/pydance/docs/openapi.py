"""
OpenAPI/Swagger Documentation Generator for Pydance

Automatically generates OpenAPI 3.0 documentation from Pydance applications.
"""

import inspect
import re
from typing import Dict, Any, List, Optional, Type, get_type_hints
from dataclasses import dataclass, field

from pydance.http.response import Response
from pydance.server.application import Application


@dataclass
class OpenAPIInfo:
    """OpenAPI info object"""
    title: str = "Pydance API"
    version: str = "1.0.0"
    description: str = "API documentation generated by Pydance"
    terms_of_service: Optional[str] = None
    contact: Optional[Dict[str, str]] = None
    license: Optional[Dict[str, str]] = None


@dataclass
class OpenAPIServer:
    """OpenAPI server object"""
    url: str
    description: Optional[str] = None
    variables: Optional[Dict[str, Any]] = None


@dataclass
class OpenAPIParameter:
    """OpenAPI parameter object"""
    name: str
    in_: str  # query, path, header, cookie
    description: Optional[str] = None
    required: bool = False
    schema: Dict[str, Any] = field(default_factory=dict)
    example: Any = None


@dataclass
class OpenAPIRequestBody:
    """OpenAPI request body object"""
    description: Optional[str] = None
    required: bool = False
    content: Dict[str, Dict[str, Any]] = field(default_factory=dict)


@dataclass
class OpenAPIResponse:
    """OpenAPI response object"""
    description: str
    content: Dict[str, Dict[str, Any]] = field(default_factory=dict)
    headers: Dict[str, Dict[str, Any]] = field(default_factory=dict)


@dataclass
class OpenAPISchema:
    """OpenAPI schema object"""
    type: str
    format: Optional[str] = None
    items: Optional['OpenAPISchema'] = None
    properties: Dict[str, 'OpenAPISchema'] = field(default_factory=dict)
    required: List[str] = field(default_factory=list)
    example: Any = None
    enum: List[Any] = field(default_factory=list)
    description: Optional[str] = None


class OpenAPIGenerator:
    """Generate OpenAPI documentation from Pydance application"""

    def __init__(self, app: Application, info: OpenAPIInfo = None):
        self.app = app
        self.info = info or OpenAPIInfo()
        self.components = {
            'schemas': {},
            'parameters': {},
            'requestBodies': {},
            'responses': {},
            'securitySchemes': {}
        }

    def generate(self) -> Dict[str, Any]:
        """Generate complete OpenAPI specification"""
        return {
            'openapi': '3.0.3',
            'info': {
                'title': self.info.title,
                'version': self.info.version,
                'description': self.info.description,
                'termsOfService': self.info.terms_of_service,
                'contact': self.info.contact,
                'license': self.info.license,
            },
            'servers': [
                {'url': f"http://localhost:{getattr(self.app.config, 'port', 8000)}", 'description': 'Development server'}
            ],
            'paths': self._generate_paths(),
            'components': self.components,
            'tags': self._generate_tags()
        }

    def _generate_paths(self) -> Dict[str, Any]:
        """Generate paths from application routes"""
        paths = {}

        for route in self.app.router.routes:
            path = route.path
            methods = route.methods or ['GET']

            if path not in paths:
                paths[path] = {}

            for method in methods:
                paths[path][method.lower()] = self._generate_operation(route, method)

        return paths

    def _generate_operation(self, route, method: str) -> Dict[str, Any]:
        """Generate operation object for route"""
        operation = {
            'summary': f"{method} {route.path}",
            'description': self._get_function_docstring(route.handler),
            'tags': self._get_tags_from_handler(route.handler),
            'parameters': self._generate_parameters(route, method),
            'responses': self._generate_responses(route, method),
        }

        # Add request body for POST, PUT, PATCH
        if method.upper() in ['POST', 'PUT', 'PATCH']:
            operation['requestBody'] = self._generate_request_body(route, method)

        return operation

    def _generate_parameters(self, route, method: str) -> List[Dict[str, Any]]:
        """Generate parameters for operation"""
        parameters = []

        # Path parameters
        path_params = re.findall(r'\{([^}]+)\}', route.path)
        for param in path_params:
            parameters.append({
                'name': param,
                'in': 'path',
                'required': True,
                'schema': {'type': 'string'},
                'description': f'Path parameter: {param}'
            })

        # Query parameters (extracted from handler signature)
        query_params = self._extract_query_parameters(route.handler)
        for param in query_params:
            parameters.append({
                'name': param['name'],
                'in': 'query',
                'required': param['required'],
                'schema': param['schema'],
                'description': param['description']
            })

        return parameters

    def _generate_responses(self, route, method: str) -> Dict[str, Any]:
        """Generate responses for operation"""
        responses = {
            '200': {
                'description': 'Successful response',
                'content': {
                    'application/json': {
                        'schema': {'type': 'object'}
                    }
                }
            },
            '400': {
                'description': 'Bad request',
                'content': {
                    'application/json': {
                        'schema': {
                            'type': 'object',
                            'properties': {
                                'error': {'type': 'string'}
                            }
                        }
                    }
                }
            },
            '404': {
                'description': 'Not found'
            },
            '500': {
                'description': 'Internal server error'
            }
        }

        # Try to infer response schema from return type
        return_type = self._get_return_type(route.handler)
        if return_type:
            responses['200']['content']['application/json']['schema'] = self._type_to_schema(return_type)

        return responses

    def _generate_request_body(self, route, method: str) -> Dict[str, Any]:
        """Generate request body for operation"""
        # Try to infer request body from handler parameters
        body_schema = self._infer_request_body_schema(route.handler)

        return {
            'required': True,
            'content': {
                'application/json': {
                    'schema': body_schema
                }
            }
        }

    def _generate_tags(self) -> List[Dict[str, Any]]:
        """Generate tags from application structure"""
        tags = []

        # Extract tags from route paths
        route_tags = set()
        for route in self.app.router.routes:
            path_parts = [p for p in route.path.split('/') if p and not p.startswith('{')]
            if path_parts:
                route_tags.add(path_parts[0])

        for tag in route_tags:
            tags.append({
                'name': tag,
                'description': f'Operations related to {tag}'
            })

        return tags

    def _get_function_docstring(self, func: Callable) -> str:
        """Get docstring from function"""
        return inspect.getdoc(func) or ''

    def _get_tags_from_handler(self, handler: Callable) -> List[str]:
        """Extract tags from handler function"""
        # Simple tag extraction from module name
        module_name = getattr(handler, '__module__', '')
        if '.' in module_name:
            return [module_name.split('.')[-1]]
        return ['default']

    def _extract_query_parameters(self, handler: Callable) -> List[Dict[str, Any]]:
        """Extract query parameters from handler signature"""
        parameters = []

        try:
            sig = inspect.signature(handler)
            type_hints = get_type_hints(handler)

            for param_name, param in sig.parameters.items():
                if param_name == 'request':
                    continue

                # Skip path parameters
                if param_name in ['self', 'cls']:
                    continue

                param_info = {
                    'name': param_name,
                    'required': param.default == inspect.Parameter.empty,
                    'schema': self._type_to_schema(type_hints.get(param_name, str)),
                    'description': f'Query parameter: {param_name}'
                }
                parameters.append(param_info)

        except Exception:
            pass

        return parameters

    def _get_return_type(self, handler: Callable) -> Optional[Type]:
        """Get return type from handler"""
        try:
            sig = inspect.signature(handler)
            return_type = sig.return_annotation
            if return_type != inspect.Signature.empty:
                return return_type
        except Exception:
            pass
        return None

    def _type_to_schema(self, python_type: Type) -> Dict[str, Any]:
        """Convert Python type to OpenAPI schema"""
        if python_type == str:
            return {'type': 'string'}
        elif python_type == int:
            return {'type': 'integer'}
        elif python_type == float:
            return {'type': 'number'}
        elif python_type == bool:
            return {'type': 'boolean'}
        elif python_type == list or python_type == List:
            return {
                'type': 'array',
                'items': {'type': 'string'}  # Default to string array
            }
        elif python_type == dict or python_type == Dict:
            return {'type': 'object'}
        elif hasattr(python_type, '__annotations__'):  # Pydantic model or similar
            return self._model_to_schema(python_type)
        else:
            return {'type': 'string'}

    def _model_to_schema(self, model_class: Type) -> Dict[str, Any]:
        """Convert model class to schema"""
        schema = {'type': 'object', 'properties': {}}

        try:
            # Try to get fields from Pydance model
            if hasattr(model_class, '_fields'):
                for field_name, field in model_class._fields.items():
                    schema['properties'][field_name] = {
                        'type': 'string',  # Simplified
                        'description': f'Field: {field_name}'
                    }

            # Try to get annotations from Pydantic model
            elif hasattr(model_class, '__annotations__'):
                for field_name, field_type in model_class.__annotations__.items():
                    schema['properties'][field_name] = self._type_to_schema(field_type)

        except Exception:
            pass

        return schema

    def _infer_request_body_schema(self, handler: Callable) -> Dict[str, Any]:
        """Infer request body schema from handler"""
        # Simple inference - could be enhanced
        return {
            'type': 'object',
            'properties': {
                'data': {'type': 'object'}
            }
        }


def generate_openapi_spec(app: Application, info: OpenAPIInfo = None) -> Dict[str, Any]:
    """Generate OpenAPI specification from Pydance application"""
    generator = OpenAPIGenerator(app, info)
    return generator.generate()


def save_openapi_spec(app: Application, filename: str = 'openapi.json', info: OpenAPIInfo = None):
    """Save OpenAPI specification to file"""
    spec = generate_openapi_spec(app, info)

    import json
    with open(filename, 'w') as f:
        json.dump(spec, f, indent=2)

    return spec


# Integration with Pydance application
def setup_openapi_docs(app: Application, info: OpenAPIInfo = None):
    """Set up OpenAPI documentation endpoints"""

    @app.route('/openapi.json')
    async def openapi_json(request):
        """Return OpenAPI specification as JSON"""
        spec = generate_openapi_spec(app, info)
        return Response.json(spec)

    @app.route('/docs')
    async def swagger_ui(request):
        """Serve Swagger UI"""
        html = '''
        <!DOCTYPE html>
        <html>
        <head>
            <title>API Documentation</title>
            <link rel="stylesheet" type="text/css" href="https://unpkg.com/swagger-ui-dist@3.25.0/swagger-ui.css" />
            <style>
                html { box-sizing: border-box; overflow: -moz-scrollbars-vertical; overflow-y: scroll; }
                *, *:before, *:after { box-sizing: inherit; }
                body { margin:0; background: #fafafa; }
            </style>
        </head>
        <body>
            <div id="swagger-ui"></div>
            <script src="https://unpkg.com/swagger-ui-dist@3.25.0/swagger-ui-bundle.js"></script>
            <script>
                SwaggerUIBundle({
                    url: '/openapi.json',
                    dom_id: '#swagger-ui',
                    presets: [
                        SwaggerUIBundle.presets.apis,
                        SwaggerUIBundle.presets.standalone
                    ],
                    layout: "StandaloneLayout"
                });
            </script>
        </body>
        </html>
        '''
        return Response.html(html)

    @app.route('/redoc')
    async def redoc(request):
        """Serve ReDoc UI"""
        html = '''
        <!DOCTYPE html>
        <html>
        <head>
            <title>API Documentation</title>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700" rel="stylesheet">
            <style>
                body { margin: 0; padding: 0; }
            </style>
        </head>
        <body>
            <redoc spec-url='/openapi.json'></redoc>
            <script src="https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js"></script>
        </body>
        </html>
        '''
        return Response.html(html)


__all__ = [
    'OpenAPIInfo', 'OpenAPIServer', 'OpenAPIParameter', 'OpenAPIRequestBody',
    'OpenAPIResponse', 'OpenAPISchema', 'OpenAPIGenerator', 'generate_openapi_spec',
    'save_openapi_spec', 'setup_openapi_docs'
]
